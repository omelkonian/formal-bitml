<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>BitML.Contracts.Validity</title><link rel="stylesheet" href="css/Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- Validity of advertisements.</a>
<a id="105" class="Comment">------------------------------------------------------------------------</a>
<a id="178" class="Keyword">open</a> <a id="183" class="Keyword">import</a> <a id="190" href="Function.html" class="Module">Function</a> <a id="199" class="Keyword">using</a> <a id="205" class="Symbol">(</a><a id="206" href="Function.Base.html#615" class="Function">id</a><a id="208" class="Symbol">)</a>

<a id="211" class="Keyword">open</a> <a id="216" class="Keyword">import</a> <a id="223" href="Data.List.Membership.Propositional.Properties.html" class="Module">Data.List.Membership.Propositional.Properties</a>
<a id="269" class="Keyword">open</a> <a id="274" class="Keyword">import</a> <a id="281" href="Data.List.Relation.Binary.Subset.Propositional.Properties.html" class="Module">Data.List.Relation.Binary.Subset.Propositional.Properties</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Prelude.Init.html" class="Module">Prelude.Init</a>
<a id="365" class="Keyword">open</a> <a id="370" class="Keyword">import</a> <a id="377" href="Prelude.General.html" class="Module">Prelude.General</a>
<a id="393" class="Keyword">open</a> <a id="398" class="Keyword">import</a> <a id="405" href="Prelude.Lists.html" class="Module">Prelude.Lists</a>
<a id="419" class="Keyword">open</a> <a id="424" class="Keyword">import</a> <a id="431" href="Prelude.DecEq.html" class="Module">Prelude.DecEq</a>
<a id="445" class="Keyword">open</a> <a id="450" class="Keyword">import</a> <a id="457" href="Prelude.Sets.html" class="Module">Prelude.Sets</a>
<a id="470" class="Keyword">open</a> <a id="475" class="Keyword">import</a> <a id="482" href="Prelude.Measurable.html" class="Module">Prelude.Measurable</a>
<a id="501" class="Keyword">open</a> <a id="506" class="Keyword">import</a> <a id="513" href="Prelude.Collections.html" class="Module">Prelude.Collections</a>

<a id="534" class="Keyword">open</a> <a id="539" class="Keyword">import</a> <a id="546" href="BitML.BasicTypes.html" class="Module">BitML.BasicTypes</a>
<a id="563" class="Keyword">open</a> <a id="568" class="Keyword">import</a> <a id="575" href="BitML.Predicate.html" class="Module">BitML.Predicate</a> <a id="591" class="Keyword">hiding</a> <a id="598" class="Symbol">(</a><a id="599" href="BitML.Predicate.html#531" class="InductiveConstructor Operator">∣_∣</a><a id="602" class="Symbol">)</a>

<a id="605" class="Comment">-- open import Induction.WellFounded</a>

<a id="643" class="Keyword">module</a> <a id="650" href="BitML.Contracts.Validity.html" class="Module">BitML.Contracts.Validity</a>
  <a id="677" class="Symbol">(</a><a id="678" href="BitML.Contracts.Validity.html#678" class="Bound">Participant</a> <a id="690" class="Symbol">:</a> <a id="692" class="PrimitiveType">Set</a><a id="695" class="Symbol">)</a>
  <a id="699" class="Symbol">{{</a><a id="701" href="BitML.Contracts.Validity.html#701" class="Bound">_</a> <a id="703" class="Symbol">:</a> <a id="705" href="Prelude.DecEq.html#553" class="Record">DecEq</a> <a id="711" href="BitML.Contracts.Validity.html#678" class="Bound">Participant</a><a id="722" class="Symbol">}}</a>
  <a id="727" class="Symbol">(</a><a id="728" href="BitML.Contracts.Validity.html#728" class="Bound">Honest</a> <a id="735" class="Symbol">:</a> <a id="737" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a> <a id="743" href="BitML.Contracts.Validity.html#678" class="Bound">Participant</a><a id="754" class="Symbol">)</a>
  <a id="758" class="Keyword">where</a>

<a id="765" class="Keyword">open</a> <a id="770" class="Keyword">import</a> <a id="777" href="BitML.Contracts.Types.html" class="Module">BitML.Contracts.Types</a> <a id="799" href="BitML.Contracts.Validity.html#678" class="Bound">Participant</a> <a id="811" href="BitML.Contracts.Validity.html#728" class="Bound">Honest</a> <a id="818" class="Keyword">hiding</a> <a id="825" class="Symbol">(</a>B<a id="827" class="Symbol">)</a>
<a id="829" class="Keyword">open</a> <a id="834" class="Keyword">import</a> <a id="841" href="BitML.Contracts.Helpers.html" class="Module">BitML.Contracts.Helpers</a> <a id="865" href="BitML.Contracts.Validity.html#678" class="Bound">Participant</a> <a id="877" href="BitML.Contracts.Validity.html#728" class="Bound">Honest</a>

<a id="ValidAdvertisement"></a><a id="885" href="BitML.Contracts.Validity.html#885" class="Function">ValidAdvertisement</a> <a id="904" class="Symbol">:</a> <a id="906" href="BitML.Contracts.Types.html#2308" class="Record">Advertisement</a> <a id="920" class="Symbol">→</a> <a id="922" class="PrimitiveType">Set</a>
<a id="926" href="BitML.Contracts.Validity.html#885" class="Function">ValidAdvertisement</a> <a id="945" class="Symbol">(</a><a id="946" href="BitML.Contracts.Types.html#2348" class="InductiveConstructor Operator">⟨</a> <a id="948" href="BitML.Contracts.Validity.html#948" class="Bound">G</a> <a id="950" href="BitML.Contracts.Types.html#2348" class="InductiveConstructor Operator">⟩</a> <a id="952" href="BitML.Contracts.Validity.html#952" class="Bound">C</a><a id="953" class="Symbol">)</a> <a id="955" class="Symbol">=</a>
    <a id="961" class="Comment">-- (i) names in G are distinct</a>
    <a id="996" href="Data.List.Relation.Unary.Unique.Setoid.html#869" class="Datatype">Unique</a> <a id="1003" class="Symbol">(</a><a id="1004" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1010" href="BitML.Contracts.Validity.html#948" class="Bound">G</a><a id="1011" class="Symbol">)</a>

    <a id="1018" class="Comment">-- (ii) each name in C appears in G</a>
  <a id="1056" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1058" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1064" href="BitML.Contracts.Validity.html#952" class="Bound">C</a> <a id="1066" href="Data.List.Relation.Binary.Subset.Setoid.html#692" class="Function Operator">⊆</a> <a id="1068" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1074" href="BitML.Contracts.Validity.html#948" class="Bound">G</a>

    <a id="1081" class="Comment">-- (iii) the names in put_&amp;reveal_ are distinct and secrets in `if ...` appear in `reveal ...`</a>
  <a id="1178" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1180" href="Data.List.Relation.Unary.All.html#1274" class="Datatype">All</a> <a id="1184" class="Symbol">(λ{</a> <a id="1188" class="Symbol">(</a><a id="1189" href="BitML.Contracts.Validity.html#1189" class="Bound">xs</a> <a id="1192" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1194" href="BitML.Contracts.Validity.html#1194" class="Bound">as</a> <a id="1197" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1199" href="BitML.Contracts.Validity.html#1199" class="Bound">p</a><a id="1200" class="Symbol">)</a> <a id="1202" class="Symbol">→</a> <a id="1204" href="Data.List.Relation.Unary.Unique.Setoid.html#869" class="Datatype">Unique</a> <a id="1211" href="BitML.Contracts.Validity.html#1189" class="Bound">xs</a> <a id="1214" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1216" class="Symbol">(</a><a id="1217" href="BitML.Contracts.Helpers.html#4649" class="Function">secrets</a> <a id="1225" href="BitML.Contracts.Validity.html#1199" class="Bound">p</a> <a id="1227" href="Data.List.Relation.Binary.Subset.Setoid.html#692" class="Function Operator">⊆</a> <a id="1229" href="BitML.Contracts.Validity.html#1194" class="Bound">as</a><a id="1231" class="Symbol">)})</a> <a id="1235" class="Symbol">(</a><a id="1236" href="BitML.Contracts.Helpers.html#5413" class="Function">putComponents</a> <a id="1250" href="BitML.Contracts.Validity.html#952" class="Bound">C</a><a id="1251" class="Symbol">)</a>

    <a id="1258" class="Comment">-- (iv) each participant has a persistent deposit in G</a>
  <a id="1315" href="Data.Product.html#1167" class="Function Operator">×</a> <a id="1317" href="BitML.Contracts.Helpers.html#2443" class="Function">participants</a> <a id="1330" href="BitML.Contracts.Validity.html#948" class="Bound">G</a> <a id="1332" href="Data.List.Base.html#1763" class="Function Operator">++</a> <a id="1335" href="BitML.Contracts.Helpers.html#2443" class="Function">participants</a> <a id="1348" href="BitML.Contracts.Validity.html#952" class="Bound">C</a> <a id="1350" href="Data.List.Relation.Binary.Subset.Setoid.html#692" class="Function Operator">⊆</a> <a id="1352" href="BitML.Contracts.Helpers.html#6996" class="Function">persistentParticipants</a> <a id="1375" href="BitML.Contracts.Validity.html#948" class="Bound">G</a>

<a id="1378" class="Comment">-- Decision procedure.</a>
<a id="validAd?"></a><a id="1401" href="BitML.Contracts.Validity.html#1401" class="Function">validAd?</a> <a id="1410" class="Symbol">:</a> <a id="1412" class="Symbol">∀</a> <a id="1414" class="Symbol">(</a><a id="1415" href="BitML.Contracts.Validity.html#1415" class="Bound">ad</a> <a id="1418" class="Symbol">:</a> <a id="1420" href="BitML.Contracts.Types.html#2308" class="Record">Advertisement</a><a id="1433" class="Symbol">)</a> <a id="1435" class="Symbol">→</a> <a id="1437" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="1441" class="Symbol">(</a><a id="1442" href="BitML.Contracts.Validity.html#885" class="Function">ValidAdvertisement</a> <a id="1461" href="BitML.Contracts.Validity.html#1415" class="Bound">ad</a><a id="1463" class="Symbol">)</a>
<a id="1465" href="BitML.Contracts.Validity.html#1401" class="Function">validAd?</a> <a id="1474" class="Symbol">(</a><a id="1475" href="BitML.Contracts.Types.html#2348" class="InductiveConstructor Operator">⟨</a> <a id="1477" href="BitML.Contracts.Validity.html#1477" class="Bound">G</a> <a id="1479" href="BitML.Contracts.Types.html#2348" class="InductiveConstructor Operator">⟩</a> <a id="1481" href="BitML.Contracts.Validity.html#1481" class="Bound">C</a><a id="1482" class="Symbol">)</a> <a id="1484" class="Symbol">=</a>
        <a id="1494" href="Prelude.DecEq.html#3215" class="Function">unique?</a> <a id="1502" class="Symbol">(</a><a id="1503" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1509" href="BitML.Contracts.Validity.html#1477" class="Bound">G</a><a id="1510" class="Symbol">)</a>
  <a id="1514" href="Relation.Nullary.Product.html#904" class="Function Operator">×-dec</a> <a id="1520" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1526" href="BitML.Contracts.Validity.html#1481" class="Bound">C</a> <a id="1528" href="Prelude.DecEq.html#2318" class="Function Operator">⊆?</a> <a id="1531" href="BitML.Contracts.Helpers.html#3482" class="Function">names</a> <a id="1537" href="BitML.Contracts.Validity.html#1477" class="Bound">G</a>
  <a id="1541" href="Relation.Nullary.Product.html#904" class="Function Operator">×-dec</a> <a id="1547" href="Data.List.Relation.Unary.All.html#6205" class="Function">all?</a> <a id="1552" class="Symbol">(λ{</a> <a id="1556" class="Symbol">(</a><a id="1557" href="BitML.Contracts.Validity.html#1557" class="Bound">xs</a> <a id="1560" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1562" href="BitML.Contracts.Validity.html#1562" class="Bound">as</a> <a id="1565" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1567" href="BitML.Contracts.Validity.html#1567" class="Bound">p</a><a id="1568" class="Symbol">)</a> <a id="1570" class="Symbol">→</a> <a id="1572" href="Prelude.DecEq.html#3215" class="Function">unique?</a> <a id="1580" href="BitML.Contracts.Validity.html#1557" class="Bound">xs</a> <a id="1583" href="Relation.Nullary.Product.html#904" class="Function Operator">×-dec</a> <a id="1589" class="Symbol">(</a><a id="1590" href="BitML.Contracts.Helpers.html#4649" class="Function">secrets</a> <a id="1598" href="BitML.Contracts.Validity.html#1567" class="Bound">p</a> <a id="1600" href="Prelude.DecEq.html#2318" class="Function Operator">⊆?</a> <a id="1603" href="BitML.Contracts.Validity.html#1562" class="Bound">as</a><a id="1605" class="Symbol">)})</a> <a id="1609" class="Symbol">(</a><a id="1610" href="BitML.Contracts.Helpers.html#5413" class="Function">putComponents</a> <a id="1624" href="BitML.Contracts.Validity.html#1481" class="Bound">C</a><a id="1625" class="Symbol">)</a>
  <a id="1629" href="Relation.Nullary.Product.html#904" class="Function Operator">×-dec</a> <a id="1635" href="BitML.Contracts.Helpers.html#2443" class="Function">participants</a> <a id="1648" href="BitML.Contracts.Validity.html#1477" class="Bound">G</a> <a id="1650" href="Data.List.Base.html#1763" class="Function Operator">++</a> <a id="1653" href="BitML.Contracts.Helpers.html#2443" class="Function">participants</a> <a id="1666" href="BitML.Contracts.Validity.html#1481" class="Bound">C</a> <a id="1668" href="Prelude.DecEq.html#2318" class="Function Operator">⊆?</a> <a id="1671" href="BitML.Contracts.Helpers.html#6996" class="Function">persistentParticipants</a> <a id="1694" href="BitML.Contracts.Validity.html#1477" class="Bound">G</a>

<a id="1697" class="Comment">{-
------------------------------------------
-- *** Mapping while preserving validity.

private
  variable
    B : Set
    C₁ C₂ C₃ : Set

record CC-like (A : Set) : Set where
  field
    {{hc}} : A has Contract
    {{hp}} : A has PutComponent
    {{hn}} : A has Name
open CC-like {{...}} public

instance
  HCᶜ : Contract has Contract
  HCᶜ = record {collect = [_]}

  CCᶜ : CC-like Contract
  CCᶜ = record {hc = record {collect = collect}; hp = record {collect = collect}; hn = record {collect = collect}}

  CC-× : ∀ {V A : Set} {{_ : CC-like A}} → CC-like (V × A)
  CC-× = record { hc = record {collect = collect ∘ proj₂}
                ; hp = record {collect = collect ∘ proj₂}
                ; hn = record {collect = collect ∘ proj₂}
                }

  CC-List : ∀ {A : Set} {{_ : CC-like A}} → CC-like (List A)
  CC-List {{record {hc = hc; hp = hp; hn = hn}}}
        = record { hc = record {collect = collect {{H-List {{hc}}}}}
                 ; hp = record {collect = collect {{H-List {{hp}}}}}
                 ; hn = record {collect = collect {{H-List {{hn}}}}}
                 }

--

record _⊆ᶜ_ {{_ : CC-like C₁}} {{_ : CC-like C₂}} (x : C₁) (y : C₂) : Set where
  constructor _&amp;_
  field
    put⊆ : putComponents x ⊆ putComponents y
    names⊆ : names x ⊆ names y

⊆ᶜ-refl : ∀ {{_ : CC-like C₁}} (c : C₁) → c ⊆ᶜ c
⊆ᶜ-refl _ = id &amp; id

⊆ᶜ-trans : ∀ {{_ : CC-like C₁}} {{_ : CC-like C₂}} {{_ : CC-like C₃}}
            {c₁ : C₁} {c₂ : C₂} {c₃ : C₃}
  → c₁ ⊆ᶜ c₂ → c₂ ⊆ᶜ c₃ → c₁ ⊆ᶜ c₃
⊆ᶜ-trans c₁⊆ᶜc₂ c₂⊆ᶜc₃ =
  let p⊆  &amp; s⊆  = c₁⊆ᶜc₂
      p⊆′ &amp; s⊆′ = c₂⊆ᶜc₃
  in  (p⊆′ ∘ p⊆) &amp; (s⊆′ ∘ s⊆)

contracts-∷ : ∀ {{_ : CC-like C₁}} {x : C₁} {xs : List C₁}
  → contracts (x ∷ xs) ≡ contracts x ++ contracts xs

contracts-∷ {x = x}{xs} rewrite concatMap-∷ {x = x}{xs}{contracts} = refl
putComponents-∷ : ∀ {{_ : CC-like C₁}} {x : C₁} {xs : List C₁}
    → putComponents (x ∷ xs) ≡ putComponents x ++ putComponents xs
putComponents-∷ {x = x}{xs} rewrite contracts-∷ {x = x}{xs}
                                  | concatMap-++ {xs = contracts x}{contracts xs}{putComponents}
                                  = refl

names-∷ : ∀ {{_ : CC-like C₁}} {x : C₁} {xs : List C₁}
    → names (x ∷ xs) ≡ names x ++ names xs
names-∷ {x = x}{xs} rewrite contracts-∷ {x = x}{xs}
                          | concatMap-++ {xs = contracts x}{contracts xs}{names}
                          = refl

∈⇒⊆ᶜ : ∀ {{_ : CC-like C₁}} {x : C₁} {xs : List C₁} → x ∈ xs → x ⊆ᶜ xs
∈⇒⊆ᶜ {x = x}{xs} (here {xs = xs′} refl) = ⊆ᶜ-∷ˡ {x = x}{xs′}
  where
    ⊆ᶜ-∷ˡ : ∀ {{_ : CC-like C₁}} {x : C₁} {xs : List C₁}
      → x ⊆ᶜ (x ∷ xs)
    ⊆ᶜ-∷ˡ {x = x}{xs} = l &amp; r
      where
        l : putComponents x ⊆ putComponents (x ∷ xs)
        l rewrite putComponents-∷ {x = x}{xs} = ∈-++⁺ˡ

        r : names x ⊆ names (x ∷ xs)
        r rewrite names-∷ {x = x}{xs} = ∈-++⁺ˡ
∈⇒⊆ᶜ {x = x}{xs} (there {xs = xs′} x∈)  = ⊆ᶜ-∷ʳ {x = x} {xs = xs′} (∈⇒⊆ᶜ x∈)
  where
    ⊆ᶜ-∷ʳ : ∀ {{_ : CC-like C₁}} {x x′ : C₁} {xs : List C₁}
      → x ⊆ᶜ xs
      → x ⊆ᶜ (x′ ∷ xs)
    ⊆ᶜ-∷ʳ {x = x}{x′}{xs} (p⊆ &amp; n⊆) = (l ∘ p⊆) &amp; (r ∘ n⊆)
      where
        l : putComponents xs ⊆ putComponents (x′ ∷ xs)
        l rewrite putComponents-∷ {x = x′}{xs} = ∈-++⁺ʳ _

        r : names xs ⊆ names (x′ ∷ xs)
        r rewrite names-∷ {x = x′}{xs} = ∈-++⁺ʳ _

map∈-⊆ : ∀ {{_ : CC-like C₁}} {{_ : CC-like C₂}} {z : C₂}
  → (xs : List C₁)
  → xs ⊆ᶜ z
  → (∀ {x : C₁} → x ∈ xs → x ⊆ᶜ z → B)
  → List B
map∈-⊆ xs xs⊆z f = mapWith∈ xs λ {x} x∈ → f x∈ (⊆ᶜ-trans (∈⇒⊆ᶜ x∈) xs⊆z)

map-⊆ : ∀ {{_ : CC-like C₁}} {{_ : CC-like C₂}} {z : C₂}
  → (xs : List C₁)
  → xs ⊆ᶜ z
  → (∀ (x : C₁) → x ⊆ᶜ z → B)
  → List B
map-⊆ xs xs⊆ᶜz f = map∈-⊆ xs xs⊆ᶜz (λ {x} _ → f x)
-}</a>
</pre></body></html>